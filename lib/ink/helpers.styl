hide()
    opacity 0

suppress()
    display none


disable(functional=false)
    cursor default
    user-select none
    pointer-events none if !functional

/*
 * Opacity with conditional IE support.
 */

//source: http://css-tricks.com/snippets/css/cross-browser-opacity/
opacity(n)
  opacity: n
  if support_for_ie
    //ie8
    filter 'progid:DXImageTransform.Microsoft.Alpha(Opacity=%s)' % round(n * 100)
    //ie6-7
    //TODO confirm below works
    ie_prop = 'alpha(opacity=50)' % round(n*100)
    filter unquote(ie_prop)





// synopsis
// border ({border}({size} n[ n][ n][ n]), ({style} s[ s][ s][ s]), ({color} c[ c][ c][ c]))[/ {border}][/ {border}]
// border()








optional-side(prop,n)
    if n isnt ignore_side
        vendorize-unit(prop,n)
        
css-shorthand(prop,n)
    count       = length(n)
    order       = 0 0 0 0
    // Very important to keep the '-' here, because
    // it is possible the sides will be iterated upon
    // like for positional sides: `top`, `left` etc.
    // which would break if the dash was present
    // By keeping the dsah here we only use it when needed
    prop_prefix = prop isnt false ? prop+"-" : ""

    if count is 2
        order = 0 1 0 1
    else if count is 3
        order = 0 1 2 1
    else if count is 4
        order = 0 1 2 3
    else if count isnt 1
        warn('your count is wrong')

    // When prop is false, it means we want to iterate
    // over the sides, since unlike prop, there are 
    // always 4 sides. I.e. top/right/bottom/left may all
    // be assigned 'auto', but that still has to be iterated below
    if prop isnt false and count is 1
        vendorize-unit(prop,n)
    else
        for side,i in css_sides
            optional-side(prop_prefix+side,n[order[i]])





//SIDES


getPushSide(orient)
    if orient is vertical
        return vertical_push_side
    else if orient is horizontal
        return horizontal_push_side

getStart(orient)
    if orient is vertical
        "top"
    else if orient is horizontal
        "left"

getEnd(orient)
    if orient is vertical
        "bottom"
    else if orient is horizontal
        "right"



//TODO opposite terminus
// a terminus is either start or end
// converting a terminus to a side depends on orient
// i.e. start could be top or left
// i.e. end could be right or bottom
convertTerminusToSide(orient,terminus)
    if orient is 'vertical'
        if terminus is 'start'
            "top"
        else if terminus is 'end'
            "bottom"
    else if orient is 'horizontal'
        if terminus is 'start'
            "left"
        else if terminus is 'end'
            "right"

convertDirectionToSide(direction)
    if direction is "up"
        "top"
    else if direction is "down"
        "bottom"
    else
        direction
//TODO support corners like down right

oppositeSide(side)
    side = convertDirectionToSide(side)
    opposite-position(side)    

// TODO implement a dynamic version of the below functions, it should be able to work like this: sides[sides.indexof(some_side)-1], etc
//TODO implement a `by` feature, so I can `clockwise` up by 3 and get `right`
//TODO support corner turning, like going from "bottom left" to "bottom right" to "top left" etc.
clockwiseSide(side)
    side = convertDirectionToSide(side)
    if side is "top"
        "right"
    else if side is "right"
        "bottom"
    else if side is "bottom"
        "left"
    else if side is "left"
        "top"

counterClockwiseSide(side)
    side = convertDirectionToSide(side)
    if side is "top"
        "left"
    else if side is "left"
        "bottom"
    else if side is "bottom"
        "right"
    else if side is "right"
        "top"







